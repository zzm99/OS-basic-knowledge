# 虚拟内存

1. 虚拟内存技术允许执行进程不必完全在内存中，显著优点是，程序可以比物理内存大。
2. 许多情况下并不需要将整个程序放到内存中：
   1. 程序通常有处理异常错误条件的代码。
   2. 数组、链表和表通常分配了比实际所需要的更多的内存。
   3. 程序的某些选项或功能可能很少使用。
3. 能够执行只有部分在内存中的程序可带来很多好处：
   1. 程序不再受现有的物理内存空间限制。用户可以为一个巨大的虚拟地址空间编写程序，简化了编程工作量。
   2. 因为每个用户程序使用了更少的物理内存，所以更多的程序可以同时执行，CPU使用率也相应增加，而响应时间和周转时间并不增加。
   3. 由于载入或交换每个用户程序到内存所需的IO会更少，用户程序会运行得更快。
4. 虚拟内存将用户逻辑内存与物理内存分开，这在现有物理内存有限的情况下，为程序员提供了巨大的虚拟内存。
5. 除了将逻辑内存与物理内存分开，虚拟内存也允许文件和内存通过共享页而为两个或多个进程所共享，优点；
   1. 通过将共享对象映射到虚拟地址空间，系统库可为多个进程所共享。
   2. 虚拟内存允许进程共享内存。
   3. 虚拟内存可允许在用系统调用fork创建进程期间共享页，从而加快进程创建。
6. 按需调页：在需要时才调入相应的页。常为虚拟内存系统所采用。
7. 懒惰交换：只有在需要页时，才将它调入内存。
8. 需要一定形式的硬件支持来区分哪些页在内存里，哪些页在磁盘上。有效-无效位可以用于此目的。不过现在该位设置为有效时，表示相关的页既合法也在内存中，设置为无效时，表示该页不在进程的逻辑地址空间内或者是有效但是在磁盘上。
9. 访问无效的页，会产生页错误陷阱page-fault trap。处理这种陷阱。
   1.  检查进程的内部页表（通常与PCB一起保存）以确定该引用是合法还是非法的地址访问。
   2.  如果引用非法，那么终止进程，如果引用有效但是尚未调入页面，那么现在应调入。
       1. 找到一个空闲帧
       2. 调度一个磁盘操作，以便将所需要的页调入刚分配的帧。
       3. 当磁盘都操作完成时，修改进程的内部表和页表，以表示该页已在内存中。
       4. 重新开始因陷阱而中断的指令。
10. 一种极端情况时所有的页都不在内存中，就开始执行进程，这种方案称为纯粹按需调页，只有在需要时才将页调入内存。
11. 有的程序的单个指令可能访问多个页的内存，从而一个指令可能产生多个页错误，这种情况会产生令人无法接受的系统性能。幸运的是，现实情况下这种情况极为少见。程序具有局部引用，这使得按需调页的性能较为合理。
12. 写时复制技术：允许父进程与子进程开始时共享同一页面，这些页面标记为写时复制页，即如果任何一个进程需要对页进行写操作，那么就创建一个共享页的副本。所有非修改页可为父进程和子进程所共享。注意只有可能修改的页才需要标记为写时复制。
13. 当确定一个页要采用写时复制时，从哪里分配空闲页时很重要的。许多操作系统为这类请求提供了空闲缓冲池，这些空闲页在进程栈或堆必须扩展时可用于分配，或用与管理写时复制页。操作系统通常采用按需带填零的技术以分配这些页。
14. 内存的过度使用会出现以下问题：当一个用户进程执行时，一个页错误发生。操作系统会确定所需页在磁盘上的位置，但是却发现空闲帧列表上并没有空闲帧，所有内存都在使用。操作系统可以终止用户进程（不是最佳选择）；操作系统可以交换出一个进程，以释放其所有帧，并降低多道程序的级别。更常用的解决方法：页置换。
15. 基本页置换：使用页置换算法选择一个“牺牲”帧，通常使用修改位或脏位以降低额外开销（否则就存在两个页传输，一个换出一个换入）。如果该页被选择为替换页，就必须要把该页写道磁盘上去。
16. 为了实现按需调页，必须解决两个主要问题：必须开发帧分配算法和页置换算法。如果在内存中有多个进程，必须决定为每个进程各分配多少帧。而且，当需要页置换时，必须选择要置换的帧。
17. 页置换算法：
    1.  FIFO页置换：Belady异常：对有的页置换算法，页错误率可能会随着所分配的帧数的增加而增加，而原期望为进程增加内存会改善其性能。
    2.  最优置换：置换最长时间不会使用的页，难以实现，用于比较研究。
    3.  LRU页置换：实现：计数器或栈等
    4.  近似LRU页置换：页表内的每项都关联着一个引用位，每当引用一个页时，相应页表的引用位就被硬件置位。开始，操作系统会给所有引用位清零。P288
        1.  附加引用位算法 
        2.  二次机会算法 
        3.  增强型二次机会算法 
    5. 基于计数的页置换：
       1. 最不经常使用页置换算法LFU
       2. 最常使用页置换算法MFU
18. 页缓冲算法：维护一个已修改页的列表。每当调页设备空闲时，就选择一个修改页并写到磁盘上，接着重新设置其修改位。这种方案增加了当需要选择置换时干净页的概率而不必写出。另一种修改是保留一个空闲帧池，但要记住哪些页在哪些帧中。由于当帧写到磁盘上时其内容并没有修改，所以在该帧被重用之前如果需要使用原来页，那么原来页可直接从空闲帧池中取出来使用。这时并不需要IO，当一个页错误发生时，先检查所需页是否在空闲帧池中，如果不在，那么才选择一个空闲帧来读入所需页。
19. 每个进程帧的最少数量是由体系结构决定的，而最大数量是由可用物理内存的数量来决定。在这两者之间，关于帧分配还是由很多选择的。
20. 分配算法：平均分配、比例分配。对于平均和比例分配，每个进程所分配的数量会随着多道程序的级别而有所变化。如果多道程序程度增加，那么每个进程会失去一些帧来提供给新进程使用。另一方面，如果多道程序程度降低，那么原来分配给离开进程的帧可以分配给剩余进程。
21. 注意，对于平均或比例分配，高优先级进程与低优先级进程一样处理。然而根据定义，可能要给高优先级更多内存来加快其执行。另一个使用比例分配的策略，不根据进程的相对大小，而是根据进程优先级或大小和优先级的组合。
22. 页置换算法分为两大类：全局置换和局部置换。全局：从所有帧集合中选择，不管是不是其他进程的。局部：仅从自己的分配帧中选择。
23. 采用局部置换策略，分配给每个进程的帧的数量不变。
24. 全局置换算法的一个问题是进程不能控制其页错误率。
25. 局部置换不能使用其他进程的不常用的内存，所以会阻碍一个进程，因此全局置换通常会有更好的系统吞吐量，且更常用。
26. 频繁的页调换行为称为颠簸。如果一个进程在换页上用的时间要多于执行时间，那么这个进程就在颠簸。
27. 通过局部置换算法或优先置换算法能限制系统颠簸。
28. 如果总的需求大于可用帧的数量，那么有的进程就会得不到足够的帧，从而会出现颠簸。
29. 系统颠簸的原因：P294