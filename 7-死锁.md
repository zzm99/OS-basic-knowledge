# 死锁

1. 死锁的四个必要条件：互斥、占有并等待、非抢占、循环等待。
2. 死锁的处理方法：
   1. 可使用协议以预防或避免死锁，确保系统不会进入死锁状态。
   2. 可允许系统进入死锁状态，然后检测它，并加以恢复。
   3. 可忽视这个问题，认为死锁不可能在系统内发生。（为绝大多数操作系统所采用，因此应用程序开发人员需要自己来处理死锁）
3. 死锁预防是一组方法，以确保至少一个必要条件不成立。这些方法通过限制如何申请资源的方法来预防死锁。副作用是低设备使用率和系统吞吐率。
   1. 互斥：通常不能通过否定互斥条件来预防死锁，有的资源本身就是非共享的。
   2. 占有并等待：保证当一个进程申请一个资源时，不能占有其他资源。
      1. 一种可以使用过的协议是每个进程在执行前申请并获得所有资源。可以实现通过要求申请资源的系统调用在所有其他系统调用之前进行。
      2. 另一种协议允许进程在没有资源时才可申请资源。在它申请其他资源之前，它必须释放其现已分配的所有资源。
      3. 两个协议都存在资源使用率较低（不管是哪个协议，必须在开始之前申请所有的资源），可能发生饥饿的情况（所需太多，至少有一个已分配给其他进程）。
   3. 非抢占：如果一个进程占有资源并申请另一个不能立即分配的资源，那么其现已分配的资源都可被抢占。只有当进程获得其原有资源和所申请的新资源时，进程才可以重新执行。这个协议通常应用于状态可以保存和恢复的资源，如CPU寄存器和内存，一般不适用于其他资源，如打印机和磁带驱动器。
   4. 循环等待：对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源（靠程序员了，也有检查软件）。
4. 死锁避免要求操作系统事先得到有关进程申请资源和使用资源的额外信息。死锁避免算法动态地检测资源分配状态以确保循环等待条件不可能成立。资源分配状态由可用资源和已分配资源，及进程最大需求所决定。
5. 如果系统能按某个顺序为每个进程分配资源（不超过其最大值）并能避免死锁，那么系统状态就是安全的。即：如果存在一个安全序列，那么系统处于安全状态。
6. 不是所有不安全状态都能导致死锁状态。
7. 采用死锁避免算法，如果进程申请一个现已可用的资源，那么它可能必须等待。这种情况下的资源使用率可能更低。
8. 资源分配图算法。如果没有环存在，那么资源分配会使得系统处于安全状态。如果有环存在，那么分配会导致系统处于不安全状态。因此，进程必须等待其资源申请被满足。（适用于每种资源类型只有一个实例）
9. 对于每种资源类型有多个实例的资源分配系统，资源分配图算法就不适用了。
10. 银行家算法。当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量，这一数量不能超过系统资源的总和。当用户申请一组资源时，系统必须确定这些资源的分配是否仍会使系统处于安全状态，如果是，就可分配资源，否则，进程必须等待直到某个其他进程释放足够资源为止。
11. 如果一个系统既不采用死锁预防算法也不采用死锁避免算法，那么可能出现死锁，系统应提供：
    1.  一个用来检测系统状态从而确定是否出现了死锁的算法。
    2.  一个用来从死锁状态中恢复的算法。
12. 对于每种资源类型只有单个实例的情况，死锁检测就是查找等待图中有无一个环。
13. 每种资源类型可有多个实例的情况的死锁检测算法类似与银行家算法。
14. 死锁恢复：
    1.  进程终止：终止所有死锁进程、一次只终止一个进程直到取消死锁循环为之。
    2.  资源抢占：选择一个牺牲品，回滚，饥饿（确保一个进程只能有限地被选择为牺牲品，在代价因素上加上回滚次数）。