# 内存管理

1. 共享内存：将多个进程保存在内存中。
2. CPU所能直接访问地存储器只有内存和处理器内地寄存器。机器指令可以用内存地址作为参数，而不能用磁盘地址作为参数。如果数据不在内存中，那么CPU使用前必须先把数据移到内存中。
3. 完成内存访问可能需要多个CPU时钟周期，由于没有数据以便完成正在执行地指令，CPU通常选哟暂停stall。
4. 由于内存访问频繁，这种情况是难以忍受的。解决办法是在CPU和内存之间增加高速内存。这种协调速度差异的内存缓冲区，称为高速缓存cache。
5. 要确保操作系统不被用户进程所访问，以及确保用户进程不被其他用户进程访问。这种保护可通过硬件来实现。
6. 确保每个进程都有独立的内存空间。基地址寄存器含有最小的合法物理内存地址，而界限地址寄存器决定了范围的大小。
7. 内存空间保护的实现，是通过CPU硬件对用户模式所产生的每一个地址与寄存器的地址进行比较来完成的。如用户模式下执行的程序试图访问操作系统内存或其他用户内存，则会陷入到操作系统并作为致命错误处理。这种方案防止用户程序有意或无意地修改操作系统或其他用户的代码或数据结构。
8. 在磁盘上等待调入内存以便执行的进程形成输入队列。
9. 编译器通常将这些符号地址绑定bind在可重定位的地址。链接程序或加载程序再将这些可重定位的地址绑定成绝对地址。每次绑定都是从一个地址空间到另一个地址空间的映射。
10. 将指令与数据绑定到内存地址的几种情况：
    1.  编译时：如果在编译时就直到进程将在内存中的驻留地址，那么就可以生成绝对代码。
    2.  加载时：如果编译时并不知道进程将驻留在内存的什么地方，那么编译器就必须生成可重定位代码。最后绑定延迟到加载时才进行。如果开始地址发生变化，只需重新加载用户代码以引入改变值。
    3.  执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定必须延迟到执行时才进行。需要特定硬件支持。
11. CPU所生成的地址通常称为逻辑地址（虚拟地址），内存单元所看到的地址（即加载到内存地址寄存器中的地址）通常称为物理地址。
12. 运行时从虚拟地址到物理地址的映射是由被称为内存管理单元MMU的硬件设备来完成的。
13. 用户程序绝不会看到真正的物理地址。
14. 如果一个进程的整个程序和数据都必须处于物理内存中，那么进程的大小受物理内存大小的限制。为了获得更好的内存空间使用率，可以使用动态加载。一个子程序只有在调用时才被加载。所有子程序都以可重定位的形式保存在磁盘上。
15. 动态加载的有点是不用的子程序决不会被加载。
16. 动态加载不需要操作系统提供特别的支持。利用这种方法来设计程序主要是用户的责任。
17. 进程可以暂时从内存中交换到备份存储（可使用磁盘）上，当需要再次执行时再调回到内存中。
18. 内存管理器可以以足够快的速度交换进程，以便当CPU调度器需要调度CPU时，总有进程在内存内可以执行。时间片必须足够大，以保证交换之间可以进行一定量的计算。
19. 通常，一个交换出的进程需要交换回它原来所占有的内存空间。这一限制是由地址绑定方式决定的。如果绑定是在汇编时或加载时所定的，那么就不可以移动到不同的位置，如果绑定在运行时才确定，由于物理地址是在运行时才确定的，那么进程可以移到不同的地址空间。
20. 交换需要备份存储，通常是快速磁盘，容纳所有用户的内存镜像副本，提供对这些内存镜像的直接访问。
21. 系统有一个就绪队列，它包括在备份存储或在内存中准备运行的所有进程。
22. 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。
23. 现在，标准交换使用不多，交换需要很多时间，提供很少的执行时间，不是一种有效的内存管理解决方案。
24. 连续内存分配，每个进程位于一个连续的内存区域。
25. 内存分配：多分区方法：固定分区、可变分区。
26. 动态存储分配问题：从一组可用孔中选择一个空闲孔的最为常用方法：首次适应（first-fit）、最佳适应（best-fit）、最差适应（worst-fit）。
27. 模拟结果显示首次适应和最佳适应方法在执行时间和利用空间方面都好于最差适应方法。首次适应方法更快一些。
28. 内存碎片可以是内部的也可以是外部的。
29. 解决外部碎片的方法：
    1.  紧缩，移动内存内容，以便所有空闲空间合并成一整块。开销较大。并非总是可能，如果重定位是静态的，并且在汇编时或装入时进行的，那么就不能紧缩。
    2.  允许物理地址空间为非连续：分页、分段、段页式。
30. 分页将物理内存分为固定大小的块，称为帧frame，将逻辑内存分为同样大小的块，称为页page。当需要执行进程时，其页从备份存储中调入到可用的内存帧中。备份存储页分为固定大小的块，其大小与内存帧一样。
31. 分页技术不会产生外部碎片，但是还有内部碎片。
32. 对于内部碎片解决，不是页越小越好，页表中的每项都有一定的开销，该开销随着页的增大而降低。
33. 分页的重要特点：用户视角的内存和实际的物理内存的分离。
34. 用户进程不能访问非它所占用的内存，无法访问其页表所规定之外的内存，页表只包括进程所拥有的那些页。
35. 操作系统为每个进程维护了一个页表的副本，当一个进程可分配到CPU时，CPU调度程序可以根据该副本来定义硬件页表，因此分页增加了切换时间。
36. 操作系统管理物理内存，必须直到物理内存的分配细节，哪些帧已占用，这些信息保存在帧表中，每个条目对应一个帧，表示该帧空闲还是已占用，如果占用，是被哪个（或哪些）进程的哪个页占用。
37. 绝大多数操作系统为每个进程分配一个页表，页表的指针与其他寄存器的值（如指令计数器）一起存入进程控制块中。
38. 分页方案，访问一个字节需要两次内存访问，一次用于页表目录，一次用于字节。先知道真实物理地址，再访问内存位置。这样，内存访问的速度就减半，在绝大多数情况下，这种延迟是无法忍受的，还不如采用交换机制。对这一问题的标准解决方案是采用小但专用且快速的硬件缓冲，这种缓冲称为转换表缓冲区TLB。
39. 有的TLB在每个TLB条目中还保存地址空间标识符ASID，ASID可用来唯一地标识进程，并为进程提供地址空间保护。除了提供地址空间保护外，ASID也允许TLB同时包括多个不同进程的条目。如果TLB不支持独立的ASID，每次选择一个页表时（如上下文切换），TLB就必须被冲刷或删除。以确保下一个进程不会使用错误的地址转换。
40. 内存保护是通过与每个帧相关联的保护位来实现的。可以用一个位来定义一个页是可读写还是只读的。还有一个位通常与页表中的每一条目相关联，有效-无效位。
41. 分页的优点之一在于可以共享公共代码，这种考虑对分时环境特别重要，如果代码是可重入代码（或称为纯代码），则可以共享。可重入代码是不能自我修改的代码，它从不会在执行期间改变。
42. 绝大多数现代计算机系统支持大逻辑地址空间。显然，不可能在内存中连续地分配这个页表，解决方法是将页表划分为更小部分。一种方法是两级分页算法，就是将页表再分页。
43. 处理超过32位地址空间的常用方法是使用哈希页表，并以虚拟页码作为哈希值。
44. 每个进程都有一个相关页表。该进程所使用的每个页都在页表中有一项（或者每个虚拟地址都有一项，不管后者是否有效）。这种方法的缺点之一是每个页表可能有很多项，这些表可能消耗大量物理内存，却仅用来跟踪物理内存是如何使用的。为了解决这个问题，可以使用反向页表。反向页表对于每个真正的内存页或帧才有一个条目。
45. 反向页表的条目中通常需要一个地址空间标识符，以确保一个特定进程的一个逻辑页可以映射到相应的物理帧。
46. 采用反向页表的系统在实现共享内存时存在困难。共享内存通常作为被映射到一个物理地址的多虚拟地址来实现。这种标准的方法不能用到反向页表，因为此使每个物理页只有一个虚拟页条目。解决方法之一是允许页表仅包含一个虚拟地址到共享物理地址的映射，这意味着对未被映射的虚拟地址的引用将导致页错误。
47. 分段：逻辑地址空间是由一组段组成的。每个段都有名称和长度。地址指定了段名称和段内偏移。通过段表实现。